<!DOCTYPE html>
<html lang="en">
<head>
	<link type="text/css" rel="stylesheet" href="style.css">
	<link href='https://fonts.googleapis.com/css?family=Montserrat' rel='stylesheet' type='text/css'>
</head>
<body>
	<h1 id="title">Educational Standards</h1>
		<!--instructions-->
	<div id="instructions">
		<p id="text">To expand node, click on it.</p>
		<p id="text">To see crosswalks, select a node by clicking on it again.</p>
		<p id="text">To see more information about any node, hover your mouse over the node.</p>
		<p id="text">Legend: Green-Subject, Blue-Domain, Purple-Cluster, Yellow-Standard</p>
	</div>
	<script src="http://d3js.org/d3.v3.min.js"></script>
	<script>
		var canvas = d3.select("body").append("svg")
						.attr("width", 1000)
						.attr("height", 1000)
		var t1 = {};
		var s1 = {};
		var t2 = {};
		function loadCSV(file, first, second){
			d3.csv(file)
					.row(function(d){ 
						//csv[d.subjectURI] = d.objectURI; 
						return {"from" : d.subjectURI, "to" : d.objectURI, "fromNotation" : d.subjectNotation, "toNotation": d.objectNotation}})
					.get(function(error,rows){for (x in rows){
						if (first.hasOwnProperty(rows[x].from)){
							
							var level = (rows[x].toNotation.match(new RegExp("\\.","g")) || []).length;
							first[rows[x].from].push({"target": rows[x].to, "level": level, "targetCollection" : second});
						}
						else{
							var level = (rows[x].toNotation.match(new RegExp("\\.","g")) || []).length;
							var targetObject = {"target" : rows[x].to, "level" : level, "targetCollection" : second}
							first[rows[x].from] = [targetObject];
						}
						if (second.hasOwnProperty(rows[x].from)){
							var level = (rows[x].fromNotation.match(new RegExp("\\.","g")) || []).length;
							second[rows[x].to].push({"target" : rows[x].from, "level" : level, "targetCollection" : first});
						}
						else{
							var level = (rows[x].fromNotation.match(new RegExp("\\.","g")) || []).length;
							var targetObject = {"target" : rows[x].from, "level" : level, "targetCollection" : first}
							second[rows[x].to] = [targetObject];
						}
					}
					})
			}
			
		
		loadCSV("t1-s1.csv", t1, s1);
		loadCSV("t2-s1.csv", t2, s1);

		var colorNodes = ["#99ccff","#bf80ff","#ffdb4d","#ffb3ff", "#fe9900"];
		var crosswalk = canvas.append("g")
							.attr("transform", "translate(" + 100 + ","  + 900+ ")")
		var rect = crosswalk.append("rect")
								.attr("width", 1000)
								.attr("height", 200)
								.attr("fill", "black");

		var reference = {"s1.json" : s1, "t1.json" : t1, "t2.json": t2}

	function crosswalks(collection, d) {
		var source = reference[collection];
		console.log(source);
		crosswalk.selectAll("g").remove();
		if (source.hasOwnProperty(d)){
			var array = source[d];
			var backgrounds = crosswalk.selectAll("g").data(source[d]).enter().append("g")
									
									.attr("transform", function(d,i){
										var rowamt = 10 + Math.sqrt(array);
										console.log(d);
										return "translate(" + (950/(i%rowamt)*27 + 30)+ "," + ((20 * 80/Math.floor(i/rowamt)) + 20) + ")"
									})
									.attr("level", function(d,i) {
										return d["level"];
									})
									.append("circle")
										.attr("r", 40 - Math.sqrt(source[d].length))
										.attr("fill", function(d,i) {
											if (d["targetCollection"] == s1) {
												console.log("here")
												return colorNodes[d["level"] - 3];
											}
											else{
												console.log(d["level"]);
												return colorNodes[d["level"]];
											}
										});
		}
	}


	function loadCollection(collection, vertical, horizontal){
		

		var svg = canvas.append("g")
					.attr("transform", "translate(" + horizontal+ "," + vertical + ")");

		var json;

		d3.json(collection, function(error, root) {
			if (error) console.log("error");

			var focus = root;
			

		/*var pack = d3.layout.pack()
		.padding(2)
		.size([700,700])
		.value(function(d){
			if (d[0].hasOwnProperty("http://purl.org/ASN/schema/core/statementLabel")){
				switch(d[0]["http://purl.org/ASN/schema/core/statementLabel"][0]["value"]){
					case "Standard":
						return 5*Math.random()*1000;
					case "Cluster":
						return 5*Math.random()*10000;
					case "Domain" :
						return 5*Math.random()*100000;
					case "Component":
						return 5*Math.random()*1000000;
				}
			}
		});*/

		svg.append("circle")
			.attr("r", 20)
			.attr("stroke", "#00e6ac")
			.attr("fill", "#00e6ac")
			.attr("stroke-width", "1.5px")
			.on("click", function(d) {displayDomains()});

					

		/*var genInfo = root["http://asn.jesandco.org/resources/D10003FB"];
		delete root["http://asn.jesandco.org/resources/D10003FB"];
		delete root["http://asn.jesandco.org/resources/D10003FB.xml"];*/

		var Domains = [];
		var count = 0;
		for (x in root) {
			/*
			if (root[x].hasOwnProperty("http://purl.org/dc/terms/description")){
				root[x]["name"] = root[x]["http://purl.org/dc/terms/description"][0]["value"];
			}
			root[x]["children"] = [];
			if (root[x].hasOwnProperty("http://purl.org/gem/qualifiers/hasChild")){
				for (i in root[x]["http://purl.org/gem/qualifiers/hasChild"]){
					root[x]["children"].push(root[x]["http://purl.org/gem/qualifiers/hasChild"][i]["value"]);
				}
			}*/
			
			if (count == 1){
				for (y in root[x]["http://purl.org/gem/qualifiers/hasChild"]){
					Domains.push(root[x]["http://purl.org/gem/qualifiers/hasChild"][y]["value"]);
				}
			}
			count ++;
		}

		/*for (x in root){
			temp = [];
			temp.push(root[x]);
			nodeArray.push(pack.nodes(temp));
		}*/
		
		console.log(Domains);
		var surroundings = [];

		for (i in Domains){
			var pushObject = {"Level": 2, "data": Domains[i]}
			surroundings.push(pushObject);
		}
		var initialLength = Domains.length;

		var nodeDistance = 180/(surroundings.length);
		var maxAngle = 0;
		var minAngle = 0;

		var nodeRadius = 60;
		
		
		function displayDomains(){
			var node = svg.selectAll("g")
					.data(Domains)					
					.enter();

			var backgrounds = node.append("g");


			

			svg.select("circle")
				.on("click", function(d){returnPositions()});

			var circles = backgrounds.append("circle")
				.on("click", function(d,i) {
					svg.selectAll("path").remove();
					console.log(surroundings.length);
					shiftCircles(d,i,nodeDistance*2*i);
					displayInner(d,3,nodeDistance*2*i);

				});

			function returnPositions() {
				surroundings = [];
				for (i in Domains){
					var pushObject = {"Level": 2, "data": Domains[i]}
					surroundings.push(pushObject);
				}
				nodeDistance = 180/(surroundings.length);
				backgrounds.transition().duration(1000).attr("transform", function(d,i) {
							return "rotate("+ nodeDistance*2*i + ")translate(" + nodeRadius + ")";
						})
						.attr("Level", 2);
				circles.transition().duration(1500).attr("r", 7).attr("fill", colorNodes[0]);
				svg.selectAll("g").filter(function(d){return this.getAttribute("Level") > 2})
					.remove();
				svg.selectAll("path").remove();
				svg.selectAll("line").remove();
				
			}

			returnPositions();

			circles.append("title")
					.text(function(d){
						return root[d]["http://purl.org/dc/terms/description"][0]["value"];
					})

			circles
				.attr("fill", "#fff")
				.attr("r",0)
				.attr("Level", 1)
				.transition()
				.duration(1000)	
				.attr("r",7)
				.attr("stroke", "#99ccff")
				.attr("fill", "#99ccff")
				.attr("stroke-width",0)	
				.attr("stroke-width", "1.5px")

			
			/*function addLines(d,i){
				var line = d3.svg.line()
				    .x(function(d) { return x(...); })
				    .y(function(d) { return y(...); })
				    .interpolate("linear");

				svg.append("path")
					.attr("class", "line")
					.attr("d", function(d){return line(data)})
					.style("stroke","#000");
			}*/


			function shiftCircles(d,i,baseRotate) {
				surroundings = [];
				for (n in Domains){
					var pushObject = {"Level": 2, "data": Domains[n]}
					surroundings.push(pushObject);
				}
				console.log(surroundings.length);
				nodeDistance= 180/surroundings.length;
				baseRotate = 2*nodeDistance * i;
				target = d3.transform("rotate(" + baseRotate + ")translate(" + nodeRadius +")").translate;
				targetOffset = d3.transform("rotate(" + baseRotate + ")translate(8)").translate;
				var newPath = svg.append("path")
					.attr("d", d3.svg.diagonal.radial()
						.source( function(d,i){
							offset = d3.transform("rotate(" + baseRotate + ")translate(34)").translate;
							sourceObject = {"x" : offset[0], "y" : offset[1]};
							return sourceObject;
						}
						)
						.target(function(d,i){
							targetObject = {"x": target[0] - targetOffset[0], "y": target[1] - targetOffset[1]}
							return targetObject;
						}
						)
					)
					.attr("fill", "none")
					.attr("stroke", "#fff")
					.attr("Level", 1);
				//offset = d3.transform("rotate(" + baseRotate + ")translate(38)").translate;
				/*var newPath = svg.append("line")
					.attr("x1", offset[0])
					.attr("y1", offset[1])
					.attr("x2", target[0]-targetOffset[0])
					.attr("y2", target[1]-targetOffset[1])
					.attr("Level",1)
					.attr("stroke", "purple");*/
				//totalLength = newPath.node().getTotalLength();
				/*newPath
					.attr("stroke-dasharray", totalLength + " " + totalLength)
					.attr("stroke-dashoffset", totalLength)
					.transition()
					.duration(1500)
					.attr("stroke-dashoffset", 0);*/
				maxAngle = baseRotate + 25;
				minAngle = baseRotate - 25;
				var filterCondition = d;
				var coeff = (i > Domains.length/4 && i < Domains.length*3/4 ? 1 : 0);
				var thisCircle = circles.filter(function(d){return (d===filterCondition)}).transition()
					.duration(1500)
					.attr("r", 7)
					.attr("stroke","white")
					.attr("fill", "white");
				var thisBackground = backgrounds.filter(function(d){return (d===filterCondition)})
					.attr("transform", function(d,i) {
						var j = 0;
						while (j < surroundings.length && surroundings[j]["data"] != d ){
							j++;
						}
						if (j < surroundings.length) {
							surroundings.splice(j, 1);
						}
						return "rotate(" + baseRotate + ")translate(" + nodeRadius + ")";
					});
				var others = circles.filter(function(d){return !(d===filterCondition)}).transition()
					.duration(1500)
					.attr("r", 7)
					.attr("stroke","fff")
					.attr("fill", "#99ccff");
				var otherNodes = backgrounds.filter(function(d){return !(d===filterCondition)}).transition()
					.duration(1500)
					.attr("transform", function(d,i){
						return "rotate(" + ((360-(maxAngle-minAngle))/(surroundings.length-1)*i + maxAngle) + ")translate(" + nodeRadius + ")";
					});
				
				
				}
			/*node.append("text")
				.attr("dy", ".31em")
				.attr("text-anchor", "start")
				.attr("transform", "translate(8)")
				.text(function(d,i){
					return root[d]["http://purl.org/dc/terms/description"][0]["value"];
				});*/
			}

		
		function displayInner(parent, coeff, baseRotate) {
			var children = [];

			for (x in root[parent]["http://purl.org/gem/qualifiers/hasChild"]){
				children.push(root[parent]["http://purl.org/gem/qualifiers/hasChild"][x]["value"]);
			}

			var node2 = svg.selectAll("Level" + coeff)
				.data(children)
				.enter()

			
			var parentCircle = svg.selectAll("g").filter(function(d){return d===parent});
			
			
			
			var unnecessary = svg.selectAll("g").filter(function(d){return this.getAttribute("Level") > coeff-1})
				.remove();
			var unnecessary2 = svg.selectAll("path").filter(function(d){
				return coeff != 3 && this.getAttribute("Level") == (coeff-2)}).remove();

			


			var backgrounds = node2.append("g");
			backgrounds.transition().duration(1500)
					.attr("transform", function(d,i) {
						return "rotate(" + (baseRotate - (children.length/2 - 0.5 - i) *4) + ")translate(" + nodeRadius*(coeff-1) + ")";
					})
					.attr("Level", coeff);


			function paths() {
			
			origin = d3.transform(parentCircle.attr("transform")).translate;
			//origin = d3.transform("rotate(" + baseRotate + ")translate(" + (90*(coeff-2)) + ")").translate;
			originOffset = d3.transform("rotate(" + baseRotate + ")translate(8)").translate;
			

			
			var paths = node2.append("path")
					/*.attr("d", function(d,i){
						translation = "rotate(" + (baseRotate - (children.length/2 - 0.5 - i) *10) + ")translate(" + 90*(coeff-1) + ")";
						destination = d3.transform(translation).translate;
						console.log(destination);
						var sourceObject = {"x" : 100, "y" : 200};
						var targetObject = {"x" : 300, "y" : 400};
						return "M" + (destination[0]) + " " + (destination[1]) + " L" + (source[0]) + " "+ (source[1])+ "Z";
						d3.svg.diagonal()
							.source(sourceObject)
							.target(targetObject);
					})*/
					
					.attr("d", d3.svg.diagonal()
									.target(function(d,i){
										offset = d3.transform("rotate(" + (baseRotate - (children.length/2 - 0.5 - i) *4) + ")translate(8)").translate;
										
										translation = "rotate(" + (baseRotate - (children.length/2 - 0.5 - i) *4) + ")translate(" + nodeRadius*(coeff-1) + ")";
										destination = d3.transform(translation).translate;
										sourceObject = {"x" : destination[0] - offset[0], "y": destination[1] - offset[1]};
										return sourceObject;
									})
									.source(function(d,i){
										return {"x" : origin[0] + originOffset[0], "y" : origin[1] + originOffset[1]};
									})
							)
					.attr("stroke", "#fff")

					.attr("fill", "none")
					.attr("Level", coeff-1);
				var totalLength = paths.node().getTotalLength();
				paths
					.attr("stroke-dasharray", totalLength + " " + totalLength)
					.attr("stroke-dashoffset", totalLength)
					.transition()
					.duration(1500)
					.attr("stroke-dashoffset", 0);
					
					
			}
			setTimeout(function(){return paths()}, 500);



			console.log(paths);
			

			var circles = backgrounds.append("circle")
					.attr("fill", "#fff")
					.attr("stroke", "#99ccff")
					.attr("fill", "#99ccff")
					.attr("__data__", function(d){return d})
					.on("click", function(d,i) {
							shiftCircles(d,i);
							displayInner(d, coeff + 1, baseRotate);
							drawPrevious(d,i);
							crosswalks(collection, d);
						});

			circles.transition().duration(1000)
				.attr("r",7)
				.attr("stroke-width", "1.5px");

			circles.append("title")
					.text(function(d,i){
									return root[d]["http://purl.org/dc/terms/description"][0]["value"];
								});

			
			function drawPrevious(d,i){
				//origin = d3.transform(parentCircle.attr("transform")).translate;
				origin = d3.transform("rotate(" + baseRotate + ")translate(" + (nodeRadius*(coeff-1) - 8) + ")").translate;
				originOffset = d3.transform("rotate(" + baseRotate + ")translate(8)").translate;
				var newPath = svg.append("path")
					.attr("d", d3.svg.diagonal()
						.source( function(d,i){
							offset = d3.transform(parentCircle.attr("transform")).translate;
							sourceObject = {"x" : offset[0] + originOffset[0] , "y" : offset[1] + originOffset[1] };
							return sourceObject;
						}
						)
						.target(function(d,i){
							targetObject = {"x": origin[0], "y": origin[1]}
							return targetObject;
						}
						)
					)
					.attr("fill", "none")
					.attr("stroke", "#fff")
					.attr("Level", coeff-1);
			}
				
				

			function shiftCircles(d,i){
				var j = 0;
				while(j<surroundings.length){
					
					if (surroundings[j]["Level"] >= coeff){
						surroundings.splice(j,1);
					}
					else{
						j++;
					}
				}
				
				var thisIndex = i;
				
				
				nodeDistance = 180/surroundings.length;
				
				var filterCondition = d;
				//surroundings.splice(surroundings.indexOf(d),1);
				

				/*var others = backgrounds.transition()
								.duration(400)
								.attr("transform", function(d,i){
									if (i > thisIndex){
										var pushObject = {"Level": coeff, "data": d};
										surroundings.push(pushObject);
										return "rotate(" + ((360-(maxAngle-minAngle))/i + minAngle) + ")translate(90)";
									}
									else if (i < thisIndex){
										var pushObject = {"Level": coeff, "data": d};
										surroundings.push(pushObject);
										return "rotate(" + (endAngle + nodeDistance*(thisIndex - i)) + ")translate(90)";
									}
									else{
										console.log(d);
										return "rotate(" + baseRotate + ")translate(" + (90*(coeff-1)) + ")";
									}
									if (i == thisIndex){
										return "rotate(" + baseRotate + ")translate(" + (90*(coeff-1)) + ")";
									}
									else{
										var pushObject = {"Level": coeff, "data": d};
										surroundings.push(pushObject);
										return "rotate(" + ((360-(maxAngle-minAngle))/(surroundings.length-1)*i) + ")translate(90)";
									}
									
								});
				*/
				backgrounds.each(function(d,i) {
					
					if (i == thisIndex){
						this.setAttribute("transform", "rotate(" + baseRotate + ")translate(" + (nodeRadius*(coeff-1)) + ")");
					}
					else{
						var pushObject = {"Level": coeff, "data": d};
						surroundings.push(pushObject);
					}
				})

				for (x in surroundings) {
					var selected = svg.selectAll("g").filter(function(d){return d==surroundings[x]["data"]});
					selected.transition().duration(800).attr("transform", function(d,i){
						
						return "rotate(" + (((360-(maxAngle-minAngle))/(surroundings.length-1)*x) + maxAngle) + ")translate(" +  nodeRadius + ")";
					})
				}
			
				/*if (surroundings.length > Domains.length * 2){
					console.log("yes");
					for (x in surroundings){
						nodeDistance = 180/surroundings.length;
						var selected = svg.selectAll("g").filter(function(d){return d==surroundings[x]["data"]});
						selected.transition().duration(800).attr("transform", function(d,i){
							return "rotate(" + (nodeDistance*2*x) + ")translate(90)";
						})
					}
				}*/
				
				
				var thisCircle = circles.filter(function(d)	{return (d===filterCondition)})
									.transition()
									.duration(1000)
									.attr("r", 7)
									.attr("stroke", "#99ccff")
									.attr("fill", "white")
									.attr("__data__", d);
				
				var otherCircles = circles.filter(function(d){return !(d===filterCondition)})
									.attr("r", 6)
									.attr("stroke", colorNodes[coeff-2])
									.attr("fill", colorNodes[coeff-2])
									.attr("__data__", function(d){return d});

				circles.on("click",function(d,i){
					svg.selectAll("path").filter(function(d,i){return this.getAttribute("Level") >= coeff}).remove();
					shiftCircles(d,i);
					crosswalks(collection,d);
					displayInner(d,coeff+1,baseRotate)}
				);
					setTimeout(function(){drawPrevious(d,i)}, 400);
				}

						/*.on("mouseover", function(d,i) {

						})			*/	
			}
					/*if (root[d].hasOwnProperty("http://purl.org/ASN/schema/core/statementLabel")){
						switch(root[d]["http://purl.org/ASN/schema/core/statementLabel"][0]["value"]){
							case "Standard":
								return 5;
							case "Cluster":
								return 10;
							case "Domain" :
								return 20;
							case "Component":
								return 2;
						};
						return 10;*/
						
		});

	}
	loadCollection("s1.json", 400, 550);
	loadCollection("t1.json", 700, 200);
	loadCollection("t2.json", 700, 900);
	</script>

	<!--buttons-->
	<div id="buttons">
	<button id="math">M</button>
	<button id="english">E</button>
	</div>
	<!---->
</body>
</html>