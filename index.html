<!DOCTYPE html>
<html lang="en" >
<head>
	<link type="text/css" rel="stylesheet" href="style.css">
	<link href='https://fonts.googleapis.com/css?family=Montserrat' rel='stylesheet' type='text/css'>
</head>
<body>
	<h1 id="title">Educational Standards</h1>
		<!--instructions-->
	<div id="instructions">
		<p id="text">To expand node, click on it.</p>
		<p id="text">To see crosswalks, select a node by clicking on it again.</p>
		<p id="text">To see more information about any node, hover your mouse over the node.</p>
	</div>
	<div id="svg">
	<script src="http://d3js.org/d3.v3.min.js"></script>
	<script>

	
		var qualifier = "http://purl.org/gem/qualifiers/"
		var dc = "http://purl.org/dc/terms/"
		var canvas = d3.select("#svg").append("svg")
						.attr("width", 1100)
						.attr("height", 1050)
						/*.attr("transform", "translate(0,50)")*/

		var t1 = {};
		var s1 = {};
		var t2 = {};
		function loadCSV(file, first, second){
			d3.csv(file)
					.row(function(d){ 
						return {"from" : d.subjectURI, "to" : d.objectURI, "fromNotation" : d.subjectNotation, "toNotation": d.objectNotation}})
					.get(function(error,rows){for (x in rows){
						if (first.hasOwnProperty(rows[x].from)){
							var level = (rows[x].toNotation.match(new RegExp("\\.","g")) || []).length;
							first[rows[x].from].push({"target": rows[x].to, "level": level, "targetCollection" : second});
						}
						else{
							var level = (rows[x].toNotation.match(new RegExp("\\.","g")) || []).length;
							var targetObject = {"target" : rows[x].to, "level" : level, "targetCollection" : second}
							first[rows[x].from] = [targetObject];
						}
						if (second.hasOwnProperty(rows[x].from)){
							var level = (rows[x].fromNotation.match(new RegExp("\\.","g")) || []).length;
							second[rows[x].to].push({"target" : rows[x].from, "level" : level, "targetCollection" : first});
						}
						else{
							var level = (rows[x].fromNotation.match(new RegExp("\\.","g")) || []).length;
							var targetObject = {"target" : rows[x].from, "level" : level, "targetCollection" : first}
							second[rows[x].to] = [targetObject];
						}
					}
					})
			}
			
		
		loadCSV("t1-s1.csv", t1, s1);
		loadCSV("t2-s1.csv", t2, s1);
		var colorNodes = ["#99ccff","#bf80ff","#ffdb4d","#ffb3ff", "#fe9900"];
		var crosswalk = canvas.append("g")
							.attr("transform", "translate( " + 0 +  ","  + 920+ ")")
		var rect = crosswalk.append("rect")
								.attr("width", 1300)
								.attr("height", 300)
								.attr("fill", "black");
		var reference = {"s1.json" : s1, "t1.json" : t1, "t2.json": t2}
		var roots = {};
		var selected = null;
		var selectedColor = null;

	function crosswalks(collection, d) {
		var source = reference[collection];
		if (collection == "t1.json" || collection == "t2.json"){
			var root = [roots["s1.json"]];
		}
		else{
			var root = [roots["t1.json"], roots["t2.json"]];
		}
		console.log(collection);
		console.log(source);
		console.log(root);
		crosswalk.selectAll("g").remove();
		if (source.hasOwnProperty(d)){
			var array = source[d];
			var backgrounds = crosswalk.selectAll("g").data(source[d]).enter().append("g")
									.attr("transform", function(d,i){
										return "translate(" + ((i%30)*29 + 120)+ "," + ((23 * Math.floor(i/30)) + 27) + ")"
									})
									.attr("level", function(d,i) {
										return d["level"];
									})
									.append("circle")
										.attr("r", 10)
										.attr("fill", function(d,i) {
											if (d["targetCollection"] == s1) {
												return colorNodes[d["level"] - 3];
											}
											else{return colorNodes[d["level"]];}
										})
										.append("title")
											.text(function(d,i){
												console.log(d["target"]);
												if (root.length == 1) {
													var junk = "http://purl.org/ASN/scheme/ASNEducationLevel/"
													result = root[0][d["target"]][dc + "description"][0]["value"] + "\n" + "Education Level: "
													for (x in root[0][d["target"]][dc + "educationLevel"]){
														appending = root[0][d["target"]][dc+ "educationLevel"][x]["value"].replace(junk, "");
														result = result + appending + ", ";
													} ;
													return result;
												}
												else{
													if (root[0].hasOwnProperty(d["target"])){
														return root[0][d["target"]][dc + "description"][0]["value"];
													}
													else{
														return root[1][d["target"]][dc + "description"][0]["value"];
													}
												}
											})
		}
	}

	function selectCircle(circle) {
		if (selected != null) {
			selected.setAttribute("fill", selectedColor);
		}
		if (circle != null){
			selected = circle;
			selectedColor = selected.getAttribute("fill");
			circle.setAttribute("fill", "white");
		}
	}


	var previous;
	function loadCollection(collection, vertical, horizontal){
		var svg = canvas.append("g")
					.attr("transform", "translate(" + horizontal+ "," + vertical + ")");
		var json;
		d3.json(collection, function(error, root) {
			if (error) console.log("error");
			roots[collection] = root;
			var focus = root;
		svg.append("circle")
			.attr("r", 20)
			.attr("stroke", "white")
			.attr("fill", "#00e6ac")
			.attr("stroke-width", "1.5px")
			.attr("expanded", false)
			.on("click", function(d) {
				console.log(this.getAttribute("expanded"));
				if (this.getAttribute("expanded") == "false") {
					this.setAttribute("expanded", true); 
					displayDomains()}
				else{
					console.log("hi");
					svg.selectAll("g").transition().duration(800).attr("transform", "translate(0)");
					setTimeout(function(){svg.selectAll("g").remove()}, 600);
					svg.selectAll("path").remove();
					this.setAttribute("expanded", false);
				}
			});


		var Domains = [];
		var count = 0;
		for (x in root) {
			
			if (count == 1){
				for (y in root[x][qualifier + "hasChild"]){
					Domains.push(root[x][qualifier + "hasChild"][y]["value"]);
				}
			}
			count ++;
		}

		console.log(Domains);
		var surroundings = [];

		for (i in Domains){
			var pushObject = {"Level": 2, "data": Domains[i]}
			surroundings.push(pushObject);
		}
		var initialLength = Domains.length;

		var nodeDistance = 180/(surroundings.length);
		var maxAngle = 0;
		var minAngle = 0;
		var nodeRadius = 60;
		
		function displayDomains(){
			var node = svg.selectAll("g")
					.data(Domains)					
					.enter();
			var backgrounds = node.append("g");
			var circles = backgrounds.append("circle")
				.attr("expanded", "false")
				.on("click", function(d,i) {
					svg.selectAll("path").remove();
					if (this.getAttribute("expanded") == "false"){
						selectCircle(this);
						if (previous != null) {
							previous.setAttribute("expanded", "false");
						}
						previous = this;
						//returnPositions();
						crosswalks(collection,d);
						shiftCircles(d,i,nodeDistance*2*i);
						this.setAttribute("expanded", "true");
						displayInner(d,3,nodeDistance*2*i);
					}
					else{
						this.setAttribute("expanded", "false");
						var theseCircles = svg.selectAll("g").filter(function(d){
							return this.getAttribute("Level") > 2;
						})
						theseCircles.transition().duration(800).attr("transform", "translate(0)")
						setTimeout(function(){theseCircles.remove()}, 600);
						selectCircle(null);
						unselect(d,3);
						returnPositions();
					}
				});

			function unselect(d, coeff) {
				filterCondition = d;
				svg.selectAll("g").filter(function(d) {return d == filterCondition})
										.selectAll("circle")
											.attr("fill", colorNodes[coeff-3])						
			}

			function returnPositions() {
				surroundings = [];
				for (i in Domains){
					var pushObject = {"Level": 2, "data": Domains[i]}
					surroundings.push(pushObject);
				}
				nodeDistance = 180/(surroundings.length);
				backgrounds.transition().duration(1000).attr("transform", function(d,i) {
							return "rotate("+ nodeDistance*2*i + ")translate(" + nodeRadius + ")";
						})
						.attr("Level", 2);
				circles.transition().duration(1500).attr("r", 7).attr("fill", colorNodes[0]);
			}

			returnPositions();
			circles.append("title")
					.text(function(d){
						var junk = "http://purl.org/ASN/scheme/ASNEducationLevel/"
						result = root[d][dc + "description"][0]["value"] + "\n" + "Education Level: "
						for (x in root[d][dc + "educationLevel"]){
							appending = root[d][dc+ "educationLevel"][x]["value"].replace(junk, "");
							result = result + appending + ", ";
						} ;
						return result;
					})
			circles
				.attr("fill", "#fff")
				.attr("r",0)
				.attr("Level", 1)
				.transition()
				.duration(1000)	
				.attr("r",7)
				.attr("stroke", "white")
				.attr("fill", "#99ccff")
				.attr("stroke-width",0)	
				.attr("stroke-width", "1px")


			function shiftCircles(d,i,baseRotate) {
				console.log(baseRotate);
				surroundings = [];
				for (n in Domains){
					var pushObject = {"Level": 2, "data": Domains[n]}
					surroundings.push(pushObject);
				}
				nodeDistance= 180/surroundings.length;
				baseRotate = 2*nodeDistance * i;
				console.log(baseRotate);
				target = d3.transform("rotate(" + baseRotate + ")translate(" + nodeRadius +")").translate;
				targetOffset = d3.transform("rotate(" + baseRotate + ")translate(8)").translate;
				var newPath = svg.append("path")
					.attr("d", d3.svg.diagonal.radial()
						.source( function(d,i){
							offset = d3.transform("rotate(" + baseRotate + ")translate(34)").translate;
							sourceObject = {"x" : offset[0], "y" : offset[1]};
							return sourceObject;
						}
						)
						.target(function(d,i){
							targetObject = {"x": target[0] - targetOffset[0], "y": target[1] - targetOffset[1]}
							return targetObject;
						}
						)
					)
					.attr("fill", "none")
					.attr("stroke", "#fff")
					.attr("Level", 1);
				
				maxAngle = baseRotate + 25;
				minAngle = baseRotate - 25;
				var filterCondition = d;
				var coeff = (i > Domains.length/4 && i < Domains.length*3/4 ? 1 : 0);
				var thisCircle = circles.filter(function(d){return (d===filterCondition)}).transition()
					.duration(1500)
					.attr("r", 7)
					.attr("fill", "white");
				var thisBackground = backgrounds.filter(function(d){return (d===filterCondition)})
					.attr("transform", function(d,i) {
						var j = 0;
						while (j < surroundings.length && surroundings[j]["data"] != d ){
							j++;
						}
						if (j < surroundings.length) {
							surroundings.splice(j, 1);
						}
						return "rotate(" + baseRotate + ")translate(" + nodeRadius + ")";
					});
				var others = circles.filter(function(d){return !(d===filterCondition)}).transition()
					.duration(1500)
					.attr("r", 7)
					.attr("stroke","#fff")
					.attr("fill", "#99ccff");
				var otherNodes = backgrounds.filter(function(d){return !(d===filterCondition)}).transition()
					.duration(1500)
					.attr("transform", function(d,i){
						return "rotate(" + ((360-(maxAngle-minAngle))/(surroundings.length-1)*i + maxAngle) + ")translate(" + nodeRadius + ")";
					});	
				}
			}

		
		function displayInner(parent, coeff, baseRotate) {
			var children = [];
			for (x in root[parent][qualifier + "hasChild"]){
				children.push(root[parent][qualifier + "hasChild"][x]["value"]);
			}
			var node2 = svg.selectAll("Level" + coeff)
				.data(children)
				.enter()
			var parentCircle = svg.selectAll("g").filter(function(d){return d===parent});
			console.log(surroundings);		
			var unnecessary = svg.selectAll("g").filter(function(d){return this.getAttribute("Level") > coeff-1})
				.remove();
			var unnecessary2 = svg.selectAll("path").filter(function(d){
				return coeff != 3 && this.getAttribute("Level") == (coeff-2)}).remove();
			var backgrounds = node2.append("g");
			backgrounds.transition().duration(1500)
					.attr("transform", function(d,i) {
						return "rotate(" + (baseRotate - (children.length/2 - 0.5 - i) *4) + ")translate(" + nodeRadius*(coeff-1) + ")";
					})
					.attr("Level", coeff);

			function paths() {
			origin = d3.transform(parentCircle.attr("transform")).translate;
			originOffset = d3.transform("rotate(" + baseRotate + ")translate(8)").translate;
			var paths = node2.append("path")
					.attr("d", d3.svg.diagonal()
									.target(function(d,i){
										offset = d3.transform("rotate(" + (baseRotate - (children.length/2 - 0.5 - i) *4) + ")translate(8)").translate;
										
										translation = "rotate(" + (baseRotate - (children.length/2 - 0.5 - i) *4) + ")translate(" + nodeRadius*(coeff-1) + ")";
										destination = d3.transform(translation).translate;
										sourceObject = {"x" : destination[0] - offset[0], "y": destination[1] - offset[1]};
										return sourceObject;
									})
									.source(function(d,i){
										return {"x" : origin[0] + originOffset[0], "y" : origin[1] + originOffset[1]};
									})
							)
					.attr("stroke", "#fff")
					.attr("fill", "none")
					.attr("Level", coeff-1);
				var totalLength = paths.node().getTotalLength();
				paths
					.attr("stroke-dasharray", totalLength + " " + totalLength)
					.attr("stroke-dashoffset", totalLength)
					.transition()
					.duration(1000)
					.attr("stroke-dashoffset", 0);
			}
			setTimeout(function(){return paths()}, 500);
			console.log(paths);

			var circles = backgrounds.append("circle")
					.attr("stroke", "white")
					.attr("fill", colorNodes[coeff-2])
					.attr("__data__", function(d){return d})
					.on("click", function(d,i) {
							shiftCircles(d,i);
							selectCircle(this);
							displayInner(d, coeff + 1, baseRotate);
							drawPrevious(d,i);
							crosswalks(collection, d);
						});
			circles.transition().duration(1000)
				.attr("r",7)
				.attr("stroke-width", "1.5px");
			circles.append("title")
					.text(function(d,i){
									var junk = "http://purl.org/ASN/scheme/ASNEducationLevel/"
									result = root[d][dc + "description"][0]["value"] + "\n" + "Education Level: "
									for (x in root[d][dc + "educationLevel"]){
										appending = root[d][dc+ "educationLevel"][x]["value"].replace(junk, "");
										result = result + appending + ", ";
									} ;
									return result;
								});
			
			function drawPrevious(d,i){
				origin = d3.transform("rotate(" + baseRotate + ")translate(" + (nodeRadius*(coeff-1) - 8) + ")").translate;
				originOffset = d3.transform("rotate(" + baseRotate + ")translate(8)").translate;
				var newPath = svg.append("path")
					.attr("d", d3.svg.diagonal()
						.source( function(d,i){
							offset = d3.transform(parentCircle.attr("transform")).translate;
							sourceObject = {"x" : offset[0] + originOffset[0] , "y" : offset[1] + originOffset[1] };
							return sourceObject;
						}
						)
						.target(function(d,i){
							targetObject = {"x": origin[0], "y": origin[1]}
							return targetObject;
						}
						)
					)
					.attr("fill", "none")
					.attr("stroke", "#fff")
					.attr("Level", coeff-1);
				var totalLength = newPath.node().getTotalLength();
				newPath
					.attr("stroke-dasharray", totalLength + " " + totalLength)
					.attr("stroke-dashoffset", totalLength)
					.transition()
					.duration(1000)
					.attr("stroke-dashoffset", 0);
			}
					

			function shiftCircles(d,i){
				var j = 0;
				while(j<surroundings.length){
					if (surroundings[j]["Level"] >= coeff){
						surroundings.splice(j,1);
					}
					else{
						j++;
					}
				}
				var thisIndex = i;	
				nodeDistance = 180/surroundings.length;				
				var filterCondition = d;			
				backgrounds.each(function(d,i) {				
					if (i == thisIndex){
						this.setAttribute("transform", "rotate(" + baseRotate + ")translate(" + (nodeRadius*(coeff-1)) + ")");
					}
					else{
						var pushObject = {"Level": coeff, "data": d};
						surroundings.push(pushObject);
					}
				})

				for (x in surroundings) {
					var selected = svg.selectAll("g").filter(function(d){return d==surroundings[x]["data"]});

					selected.transition().duration(800).attr("transform", function(d,i){
						return "rotate(" + (((360-(maxAngle-minAngle))/(surroundings.length-1)*x) + maxAngle) + ")translate(" +  nodeRadius + ")";
					})
				}
				
				var thisCircle = circles.filter(function(d)	{return (d===filterCondition)})
									.transition()
									.duration(1000)
									.attr("r", 7)
									.attr("fill", "white")
									.attr("__data__", d);
				
				var otherCircles = circles.filter(function(d){return !(d===filterCondition)})
									.attr("r", 6)
									.attr("stroke", "white")
									.attr("fill", colorNodes[coeff-2])
									.attr("__data__", function(d){return d});
				circles.on("click",function(d,i){
					svg.selectAll("path").filter(function(d,i){return this.getAttribute("Level") >= coeff}).remove();
					shiftCircles(d,i);
					crosswalks(collection,d);
					selectCircle(this);
					displayInner(d,coeff+1,baseRotate)}
				);
					setTimeout(function(){drawPrevious(d,i)}, 400);
				}
			}
		});
	}

	loadCollection("s1.json", 350, 550);
	loadCollection("t1.json", 650, 200);
	loadCollection("t2.json", 650, 900);
	</script>
</div>

	<!--buttons-->
	<div id="buttons">
	<button id="math">M</button>
	<button id="english">E</button>
	</div>
	<!---->
</body>
</html>